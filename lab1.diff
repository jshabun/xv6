diff --git a/Makefile b/Makefile
index 09d790c..e0e9b9a 100644
--- a/Makefile
+++ b/Makefile
@@ -170,6 +170,7 @@ UPROGS=\
 	_echo\
 	_forktest\
 	_grep\
+	_hello\
 	_init\
 	_kill\
 	_ln\
@@ -181,6 +182,7 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
+	_test\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
diff --git a/defs.h b/defs.h
index 82fb982..0bc8e85 100644
--- a/defs.h
+++ b/defs.h
@@ -118,8 +118,12 @@ void            setproc(struct proc*);
 void            sleep(void*, struct spinlock*);
 void            userinit(void);
 int             wait(void);
+int             wait2(int*);
 void            wakeup(void*);
 void            yield(void);
+void            hello(void);
+int             exit2(int);
+int             waitpid(int, int*, int);
 
 // swtch.S
 void            swtch(struct context**, struct context*);
diff --git a/proc.c b/proc.c
index 806b1b1..a7cf388 100644
--- a/proc.c
+++ b/proc.c
@@ -532,3 +532,142 @@ procdump(void)
     cprintf("\n");
   }
 }
+
+// lab 0
+
+void
+hello(void) {
+  cprintf("\n\n Hello from your kernel space! \n\n");
+}
+
+// lab 1
+int
+exit2(int status)
+{
+ // cprintf("Exit status: %d\n", status);
+
+  struct proc *curproc = myproc();
+  struct proc *p;
+  int fd;
+
+  if(curproc == initproc)
+    panic("init exiting");
+  for(fd = 0; fd < NOFILE; fd++){
+    if(curproc->ofile[fd]){
+      fileclose(curproc->ofile[fd]);
+      curproc->ofile[fd] = 0;
+    }
+  }
+
+  begin_op();
+  iput(curproc->cwd);
+  end_op();
+  curproc->cwd = 0;
+
+  acquire(&ptable.lock);
+  wakeup1(curproc->parent);
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if(p->parent == curproc){
+      p->parent = initproc;
+      if(p->state == ZOMBIE)
+    wakeup1(initproc);
+    }
+  }
+  curproc->state = ZOMBIE;
+  curproc->exitstat = status;
+  sched();
+  panic("zombie exit");
+}
+
+int waitpid (int pid, int* status, int options)
+{
+  struct proc *p;
+  int is_here, pid2;
+  struct proc *curproc = myproc();
+
+
+  acquire(&ptable.lock);
+  for(;;)
+  {
+    //copied from og wait() ^^
+    // Scan through table looking for zombie children.
+    is_here = 0;
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    {
+        if(p->pid != pid)
+        continue;
+      is_here = 1;
+      if(p->state == ZOMBIE){
+        // Found one.
+        pid2 = p->pid;
+        kfree(p->kstack);
+        p->kstack = 0;
+        freevm(p->pgdir);
+        p->state = UNUSED;
+        p->pid = 0;
+        p->parent = 0;
+        p->name[0] = 0;
+        p->killed = 0;
+        release(&ptable.lock);
+
+
+        if (status != 0)
+        {
+          *status = p->exitstat;
+        }
+        return pid2;
+      }
+    }
+
+    if(!is_here || curproc->killed){
+
+      release(&ptable.lock);
+      return -1;
+    }
+    sleep(curproc, &ptable.lock);
+  }
+}
+int
+wait2(int *status)
+{
+  struct proc *p;
+  int havekids, pid;
+  struct proc *curproc = myproc();
+  
+  acquire(&ptable.lock);
+  for(;;){
+    // Scan through table looking for exited children.
+    havekids = 0;
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->parent != curproc)
+        continue;
+      havekids = 1;
+      if(p->state == ZOMBIE){
+        // Found one.
+        pid = p->pid;
+        kfree(p->kstack);
+        p->kstack = 0;
+        freevm(p->pgdir);
+        p->pid = 0;
+        p->parent = 0;
+        p->name[0] = 0;
+        p->killed = 0;
+        p->state = UNUSED;
+        if(status) {
+          *status = p->exitstat;
+        }
+        release(&ptable.lock);
+        return pid;
+      }
+    }
+
+    // No point waiting if we don't have any children.
+    if(!havekids || curproc->killed){
+      release(&ptable.lock);
+      return -1;
+    }
+
+    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+  }
+}
\ No newline at end of file
diff --git a/proc.h b/proc.h
index 1647114..f612310 100644
--- a/proc.h
+++ b/proc.h
@@ -49,6 +49,7 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  int exitstat;
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/syscall.c b/syscall.c
index ee85261..99802ef 100644
--- a/syscall.c
+++ b/syscall.c
@@ -103,6 +103,10 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_hello(void);
+extern int sys_exit2(void);
+extern int sys_waitpid(void);
+extern int sys_wait2(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +130,10 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_hello]   sys_hello,
+[SYS_exit2]   sys_exit2,
+[SYS_waitpid] sys_waitpid,
+[SYS_wait2]   sys_wait2,
 };
 
 void
diff --git a/syscall.h b/syscall.h
index bc5f356..c1cfb64 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,7 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_hello  22
+#define SYS_exit2  23
+#define SYS_waitpid 24
+#define SYS_wait2  25
\ No newline at end of file
diff --git a/sysproc.c b/sysproc.c
index 0686d29..eb499fa 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -26,6 +26,7 @@ sys_wait(void)
   return wait();
 }
 
+// ------------------
 int
 sys_kill(void)
 {
@@ -89,3 +90,58 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+// lab 0
+int
+sys_hello(void)
+{
+  hello();
+  return 0;
+}
+
+// lab 1
+int
+sys_exit2(void)
+{
+  int status;
+  if(argint(0, &status) < 0)
+  {
+    return -1;
+  }
+  return exit2(status);
+}
+
+int
+sys_waitpid(void)
+{ 
+  int pid;
+  int options = 0;
+  int* status;
+
+  if(argint(0, &pid) < 0)
+  {
+    return -1;
+  }
+  if(argptr(1,(void*)&status, sizeof(status)) < 0)
+  { 
+    return -1; 
+  }
+  return waitpid(pid, status, options);
+}
+
+//updating wait 
+/* 
+The wait system call must prevent the current process from execution until any of its child
+processes is terminated (if any exists) and return the terminated child exit status through
+the status argument.
+
+- Return the terminated child procâ€™s exit status through the status pointer argument;
+
+*/
+int
+sys_wait2(void)
+{
+  int *status;
+  argptr(0, (void*)&status, sizeof(status));
+  return wait2(status);
+}
\ No newline at end of file
diff --git a/user.h b/user.h
index 4f99c52..acf470f 100644
--- a/user.h
+++ b/user.h
@@ -23,6 +23,10 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int hello(void);
+int exit2(int);
+int waitpid(int, int*, int);
+int wait2(int*);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/usys.S b/usys.S
index 8bfd8a1..bd4c491 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,7 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(hello)
+SYSCALL(exit2)
+SYSCALL(waitpid)
+SYSCALL(wait2)
